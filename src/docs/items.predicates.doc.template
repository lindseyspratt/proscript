<div class="indexed" id="pred_cat_arithmetic">
<h4>arithmetic</h4>
<ul>
<li class="indexed" id="pred_<_2">
<h5>(<)/2</h5>
<br><b><</b>(+<i>Left</i>:term,+<i>Right</i>:term) is det
<br><br>The value of the arithmetic expression Left is less than the value of the arithmetic expression Right.
<br>
<br><b>arg</b>: <i>Left</i>. an arithmetic expression term.
<br><b>arg</b>: <i>Right</i>. an arithmetic expression term.
<br><b>compat</b>: iso.
<br><b>cat</b>: arithmetic.
</li>

<li class="indexed" id="pred_=:=_2">
<h5>(=:=)/2</h5>
<br><b>=:=</b>(+<i>Left</i>:term,+<i>Right</i>:term) is det
<br><br>The value of the arithmetic expression Left is equal  to the value of the arithmetic expression Right.
<br>
<br><b>arg</b>: <i>Left</i>. an arithmetic expression term.
<br><b>arg</b>: <i>Right</i>. an arithmetic expression term.
<br><b>compat</b>: iso.
<br><b>cat</b>: arithmetic.
</li>

<li class="indexed" id="pred_=<_2">
<h5>(=<)/2</h5>
<br><b>=<</b>(+<i>Left</i>:term,+<i>Right</i>:term) is det
<br><br>The value of the arithmetic expression Left is equal to or less than the value of the arithmetic expression Right.
<br>
<br><b>arg</b>: <i>Left</i>. an arithmetic expression term.
<br><b>arg</b>: <i>Right</i>. an arithmetic expression term.
<br><b>compat</b>: iso.
<br><b>cat</b>: arithmetic.
</li>

<li class="indexed" id="pred_=\=_2">
<h5>(=\=)/2</h5>
<br><b>=\=</b>(+<i>Left</i>:term,+<i>Right</i>:term) is det
<br><br>The value of the arithmetic expression Left is not equal  to the value of the arithmetic expression Right.
<br>
<br><b>arg</b>: <i>Left</i>. an arithmetic expression term.
<br><b>arg</b>: <i>Right</i>. an arithmetic expression term.
<br><b>compat</b>: iso.
<br><b>cat</b>: arithmetic.
</li>

<li class="indexed" id="pred_>_2">
<h5>(>)/2</h5>
<br><b>></b>(+<i>Left</i>:term,+<i>Right</i>:term) is det
<br><br>The value of the arithmetic expression Left is greater than the value of the arithmetic expression Right.
<br>
<br><b>arg</b>: <i>Left</i>. an arithmetic expression term.
<br><b>arg</b>: <i>Right</i>. an arithmetic expression term.
<br><b>compat</b>: iso.
<br><b>cat</b>: arithmetic.
</li>

<li class="indexed" id="pred_>=_2">
<h5>(>=)/2</h5>
<br><b>>=</b>(+<i>Left</i>:term,+<i>Right</i>:term) is det
<br><br>The value of the arithmetic expression Left is greater than or equal to the value of the arithmetic expression Right.
<br>
<br><b>arg</b>: <i>Left</i>. an arithmetic expression term.
<br><b>arg</b>: <i>Right</i>. an arithmetic expression term.
<br><b>compat</b>: iso.
<br><b>cat</b>: arithmetic.
</li>

<li class="indexed" id="pred_is_2">
<h5>(is)/2</h5>
<br><b>is</b>(?<i>Result</i>:number,+<i>Expression</i>:term) is det
<br><br>Result is the value of evaluating the arithmetic Expression.
<br>
<br><b>arg</b>: <i>Result</i>. a number.
<br><b>arg</b>: <i>Expression</i>. an arithmetic expression term.
<br><b>compat</b>: iso.
<br><b>cat</b>: arithmetic.
</li>

</ul>
</div>
<div class="indexed" id="pred_cat_atomic_term_processing">
<h4>atomic_term_processing</h4>
<ul>
<li class="indexed" id="pred_atom_chars_2">
<h5>atom_chars/2</h5>
<br><b>atom_chars</b>(?<i>Atom</i>:atom,?<i>Chars</i>:list(atom)) is det
<br><br>The name of Atom is the list of character atoms in Chars.
<br>
<br><b>arg</b>: <i>Atom</i>. an atom.
<br><b>arg</b>: <i>Chars</i>. a list of atoms.
<br><b>compat</b>: iso.
<br><b>cat</b>: atomic_term_processing.
</li>

<li class="indexed" id="pred_atom_codes_2">
<h5>atom_codes/2</h5>
<br><b>atom_codes</b>(?<i>Atom</i>:atom,?<i>Codes</i>:list(integer)) is det
<br><br>The name of Atom is the list of character integers in Codes.
<br>
<br><b>arg</b>: <i>Atom</i>. an atom.
<br><b>arg</b>: <i>Codes</i>. a list of integers.
<br><b>compat</b>: iso.
<br><b>cat</b>: atomic_term_processing.
</li>

<li class="indexed" id="pred_atom_concat_3">
<h5>atom_concat/3</h5>
<br><b>atom_concat</b>(+<i>Atom1</i>:atom,+<i>Atom2</i>:atom,?<i>Concatenation</i>:atom) is det
<br><br>The names of Atom1 and Atom2 are concatenated to create Concatenation.
<br>
<br><b>arg</b>: <i>Atom1</i>. an atom.
<br><b>arg</b>: <i>Atom2</i>. an atom.
<br><b>arg</b>: <i>Concatenation</i>. an atom.
<br><b>compat</b>: iso.
<br><b>cat</b>: atomic_term_processing.
</li>

<li class="indexed" id="pred_atom_length_2">
<h5>atom_length/2</h5>
<br><b>atom_length</b>(+<i>Atom</i>:atom,?<i>Length</i>:integer) is det
<br><br>Length is the number of characters in the name of Atom.
<br>
<br><b>arg</b>: <i>Atom</i>. an atom.
<br><b>arg</b>: <i>Length</i>. an integer.
<br><b>compat</b>: iso.
<br><b>cat</b>: atomic_term_processing.
</li>

<li class="indexed" id="pred_char_code_2">
<h5>char_code/2</h5>
<br><b>char_code</b>(?<i>Atom</i>:atom,?<i>Code</i>:integer) is det
<br><br>The name of Atom is a single character with integer character Code.
<br>
<br><b>arg</b>: <i>Atom</i>. an atom.
<br><b>arg</b>: <i>Code</i>. an integer.
<br><b>compat</b>: iso.
<br><b>cat</b>: atomic_term_processing.
</li>

<li class="indexed" id="pred_gensym_2">
<h5>gensym/2</h5>
<br><b>gensym</b>(+<i>Root</i>:atom,?<i>NewAtom</i>:atom)
<br><br>NewAtom is the concatenation of Root and increment of per-Root counter, starting at 0. Each use of gensym/2 with the same Root increments this counter.
<br>
<br><b>arg</b>: <i>Root</i>. an atom.
<br><b>arg</b>: <i>NewAtom</i>. an atom.
<br><b>compat</b>: proscriptls.
<br><b>cat</b>: atomic_term_processing.
</li>

<li class="indexed" id="pred_number_chars_2">
<h5>number_chars/2</h5>
<br><b>number_chars</b>(?<i>Number</i>:number,?<i>Chars</i>:list(atom)) is det
<br><br>The name of Number is the list of character atoms in Chars.
<br>
<br><b>arg</b>: <i>Number</i>. a number.
<br><b>arg</b>: <i>Chars</i>. a list of atoms.
<br><b>compat</b>: iso.
<br><b>cat</b>: atomic_term_processing.
</li>

<li class="indexed" id="pred_number_codes_2">
<h5>number_codes/2</h5>
<br><b>number_codes</b>(?<i>Number</i>:number,?<i>Codes</i>:list(integer)) is det
<br><br>The name of Number is the list of character integers in Codes.
<br>
<br><b>arg</b>: <i>Number</i>. a number.
<br><b>arg</b>: <i>Codes</i>. a list of integers.
<br><b>compat</b>: iso.
<br><b>cat</b>: atomic_term_processing.
</li>

<li class="indexed" id="pred_sub_atom_5">
<h5>sub_atom/5</h5>
<br><b>sub_atom</b>(+<i>Source</i>:atom,+<i>Start</i>:integer,-<i>Length</i>:integer,+<i>Remaining</i>:integer,?<i>Subatom</i>:atom) is det
<br><b>sub_atom</b>(+<i>Source</i>:atom,-<i>Start</i>:integer,+<i>Length</i>:integer,+<i>Remaining</i>:integer,?<i>Subatom</i>:atom) is det
<br><b>sub_atom</b>(+<i>Source</i>:atom,+<i>Start</i>:integer,+<i>Length</i>:integer,?<i>Remaining</i>:integer,?<i>Subatom</i>:atom) is det
<br><b>sub_atom</b>(+<i>Source</i>:atom,+<i>Start</i>:integer,-<i>Length</i>:integer,-<i>Remaining</i>:integer,-<i>Subatom</i>:atom) is nondet
<br><b>sub_atom</b>(+<i>Source</i>:atom,-<i>Start</i>:integer,+<i>Length</i>:integer,-<i>Remaining</i>:integer,?<i>Subatom</i>:atom) is nondet
<br><b>sub_atom</b>(+<i>Source</i>:atom,-<i>Start</i>:integer,-<i>Length</i>:integer,+<i>Remaining</i>:integer,?<i>Subatom</i>:atom) is nondet
<br><br>The name of Subatom is a part of the name of Source that begins at position Start and has Length characters and there are Remaining
    characters in Source after Subatom.
<br>
<br><b>arg</b>: <i>Source</i>. an atom.
<br><b>arg</b>: <i>Start</i>. an integer.
<br><b>arg</b>: <i>Length</i>. an integer.
<br><b>arg</b>: <i>Remaining</i>. an integer.
<br><b>arg</b>: <i>Subatom</i>. an atom.
<br><b>compat</b>: proscriptls.
<br><b>cat</b>: atomic_term_processing.
</li>

</ul>
</div>
<div class="indexed" id="pred_cat_byte_io">
<h4>byte_io</h4>
<ul>
<li class="indexed" id="pred_get_byte_2">
<h5>get_byte/2</h5>
<br><b>get_byte</b>(+<i>Stream</i>:term,?<i>Byte</i>:integer)
<br><br>Get next byte from Stream as Byte.
<br>
<br><b>arg</b>: <i>Stream</i>. a stream term.
<br><b>arg</b>: <i>Byte</i>. an integer.
<br><b>compat</b>: iso.
<br><b>cat</b>: byte_io.
</li>

<li class="indexed" id="pred_peek_byte_2">
<h5>peek_byte/2</h5>
<br><b>peek_byte</b>(+<i>Stream</i>:term,?<i>Byte</i>:atom)
<br><br>Peek at next byte in Stream as Byte. Do not advance stream position.
<br>
<br><b>arg</b>: <i>Stream</i>. a stream term.
<br><b>arg</b>: <i>Byte</i>. an integer.
<br><b>compat</b>: iso.
<br><b>cat</b>: byte_io.
</li>

<li class="indexed" id="pred_put_byte_2">
<h5>put_byte/2</h5>
<br><b>put_byte</b>(+<i>Stream</i>:term,?<i>Byte</i>:integer)
<br><br>Put Byte in Stream.
<br>
<br><b>arg</b>: <i>Stream</i>. a stream term.
<br><b>arg</b>: <i>Byte</i>. an integer.
<br><b>compat</b>: iso.
<br><b>cat</b>: byte_io.
</li>

</ul>
</div>
<div class="indexed" id="pred_cat_character_io">
<h4>character_io</h4>
<ul>
<li class="indexed" id="pred_get_char_1">
<h5>get_char/1</h5>
<br><b>get_char</b>(?<i>Char</i>:atom)
<br><br>Get next character from current input stream as Char.
<br>
<br><b>arg</b>: <i>Char</i>. an atom.
<br><b>compat</b>: iso.
<br><b>cat</b>: character_io.
</li>

<li class="indexed" id="pred_get_char_2">
<h5>get_char/2</h5>
<br><b>get_char</b>(+<i>Stream</i>:term,?<i>Char</i>:atom)
<br><br>Get next character from Stream as Char.
<br>
<br><b>arg</b>: <i>Stream</i>. a stream term.
<br><b>arg</b>: <i>Char</i>. an atom.
<br><b>compat</b>: iso.
<br><b>cat</b>: character_io.
</li>

<li class="indexed" id="pred_get_code_1">
<h5>get_code/1</h5>
<br><b>get_code</b>(?<i>Code</i>:integer)
<br><br>Get next character code from current input stream as Code.
<br>
<br><b>arg</b>: <i>Code</i>. an integer.
<br><b>compat</b>: iso.
<br><b>cat</b>: character_io.
</li>

<li class="indexed" id="pred_get_code_2">
<h5>get_code/2</h5>
<br><b>get_code</b>(+<i>Stream</i>:term,?<i>Code</i>:integer)
<br><br>Get next character code from Stream as Code.
<br>
<br><b>arg</b>: <i>Stream</i>. a stream term.
<br><b>arg</b>: <i>Code</i>. an integer.
<br><b>compat</b>: iso.
<br><b>cat</b>: character_io.
</li>

<li class="indexed" id="pred_peek_char_1">
<h5>peek_char/1</h5>
<br><b>peek_char</b>(?<i>Char</i>:atom)
<br><br>Peek at next character in current inpu stream as Char. Do not advance stream position.
<br>
<br><b>arg</b>: <i>Char</i>. an atom.
<br><b>compat</b>: iso.
<br><b>cat</b>: character_io.
</li>

<li class="indexed" id="pred_peek_char_2">
<h5>peek_char/2</h5>
<br><b>peek_char</b>(+<i>Stream</i>:term,?<i>Char</i>:atom)
<br><br>Peek at next character in Stream as Char. Do not advance stream position.
<br>
<br><b>arg</b>: <i>Stream</i>. a stream term.
<br><b>arg</b>: <i>Char</i>. an atom.
<br><b>compat</b>: iso.
<br><b>cat</b>: character_io.
</li>

<li class="indexed" id="pred_peek_code_1">
<h5>peek_code/1</h5>
<br><b>peek_code</b>(?<i>Code</i>:atom)
<br><br>Peek at next character code in current input stream as Code. Do not advance stream position.
<br>
<br><b>arg</b>: <i>Char</i>. an integer.
<br><b>compat</b>: iso.
<br><b>cat</b>: character_io.
</li>

<li class="indexed" id="pred_peek_code_2">
<h5>peek_code/2</h5>
<br><b>peek_code</b>(+<i>Stream</i>:term,?<i>Code</i>:atom)
<br><br>Peek at next character code in Stream as Code. Do not advance stream position.
<br>
<br><b>arg</b>: <i>Stream</i>. a stream term.
<br><b>arg</b>: <i>Char</i>. an integer.
<br><b>compat</b>: iso.
<br><b>cat</b>: character_io.
</li>

<li class="indexed" id="pred_put_char_1">
<h5>put_char/1</h5>
<br><b>put_char</b>(?<i>Char</i>:atom)
<br><br>Put Char in current output stream.
<br>
<br><b>arg</b>: <i>Char</i>. an atom.
<br><b>compat</b>: iso.
<br><b>cat</b>: character_io.
</li>

<li class="indexed" id="pred_put_char_2">
<h5>put_char/2</h5>
<br><b>put_char</b>(+<i>Stream</i>:term,?<i>Char</i>:atom)
<br><br>Put Char in Stream.
<br>
<br><b>arg</b>: <i>Stream</i>. a stream term.
<br><b>arg</b>: <i>Char</i>. an atom.
<br><b>compat</b>: iso.
<br><b>cat</b>: character_io.
</li>

<li class="indexed" id="pred_put_code_1">
<h5>put_code/1</h5>
<br><b>put_code</b>(?<i>Code</i>:integer)
<br><br>Put character Code in current output stream.
<br>
<br><b>arg</b>: <i>Code</i>. an integer.
<br><b>compat</b>: iso.
<br><b>cat</b>: character_io.
</li>

<li class="indexed" id="pred_put_code_2">
<h5>put_code/2</h5>
<br><b>put_code</b>(+<i>Stream</i>:term,?<i>Code</i>:integer)
<br><br>Put character Code in Stream.
<br>
<br><b>arg</b>: <i>Stream</i>. a stream term.
<br><b>arg</b>: <i>Code</i>. an integer.
<br><b>compat</b>: iso.
<br><b>cat</b>: character_io.
</li>

</ul>
</div>
<div class="indexed" id="pred_cat_clause_creation_and_destruction">
<h4>clause_creation_and_destruction</h4>
<ul>
<li class="indexed" id="pred_abolish_1">
<h5>abolish/1</h5>
<br><b>abolish</b>(+<i>Indicator</i>:term) is det
<br><br>Removes the (dynamic) user defined procedure identified by its predicate indicator,
    leaving the database in the same state as if this procedure had never existed.
    (as defined in the ISO standard)
<br>
<br><b>arg</b>: <i>Indicator</i>. predicate indicator term.
<br><b>compat</b>: iso.
<br><b>cat</b>: clause_creation_and_destruction.
</li>

<li class="indexed" id="pred_retract_1">
<h5>retract/1</h5>
<br><b>retract</b>(+<i>Clause</i>:term) is nondet
<br><br>Retract from the database the clauses which are unifiable with Clause.
<br>
<br><b>arg</b>: <i>Clause</i>. a clause term.
<br><b>compat</b>: iso.
<br><b>cat</b>: clause_creation_and_destruction.
</li>

<li class="indexed" id="pred_retract_clause_2">
<h5>retract_clause/2</h5>
<br><b>retract</b>(+<i>Head</i>:term,?<i>Body</i>:term) is nondet
<br><br>Retract from the database the clauses which are unifiable with Head and Body.
<br>
<br><b>arg</b>: <i>Head</i>. a callable term.
<br><b>arg</b>: <i>Body</i>. a term.
<br><b>compat</b>: iso.
<br><b>cat</b>: clause_creation_and_destruction.
</li>

</ul>
</div>
<div class="indexed" id="pred_cat_clause_retrieval_and_information">
<h4>clause_retrieval_and_information</h4>
<ul>
<li class="indexed" id="pred_clause_2">
<h5>clause/2</h5>
<br><b>clause</b>(+<i>Head</i>:term,?<i>Body</i>:term)
<br><br>A public user-defined procedure in the database has Head and Body.
<br>
<br><b>arg</b>: <i>Head</i>. a callable term.
<br><b>arg</b>: <i>Body</i>. a callable term.
<br><b>compat</b>: iso.
<br><b>cat</b>: clause_retrieval_and_information.
</li>

</ul>
</div>
<div class="indexed" id="pred_cat_dom">
<h4>dom</h4>
<ul>
<li class="indexed" id="pred_alert_1">
<h5>alert/1</h5>
<br><b>alert</b>(+<i>Term</i>:term)
<br><br>Display Term in a browser alert dialog.
<br>
<br><b>arg</b>: <i>Term</i>. any term.
<br><b>cat</b>: dom.
</li>

<li class="indexed" id="pred_append_dom_node_child_2">
<h5>append_dom_node_child/2</h5>
<br><b>append_dom_node_child</b>(+<i>Element</i>:object_id,+<i>Child</i>:object_id)
<br><br>Append a DOM node as a child node.
<br>
<br><b>arg</b>: <i>Element</i>. an object ID structure for an HTML node object.
<br><b>arg</b>: <i>Child</i>. an object ID structure for an HTML node object.
<br><b>cat</b>: dom.
</li>

<li class="indexed" id="pred_create_dom_element_2">
<h5>create_dom_element/2</h5>
<br><b>create_dom_element</b>(+<i>Tag</i>:atom,-<i>Element</i>:object_id)
<br><br>Create a DOM element object with tag Tag.
<br>
<br><b>arg</b>: <i>Tag</i>. an HTML tag name (any case).
<br><b>arg</b>: <i>Element</i>. an object ID structure for an HTML element object..
<br><b>cat</b>: dom.
</li>

<li class="indexed" id="pred_create_dom_text_node_2">
<h5>create_dom_text_node/2</h5>
<br><b>create_dom_text_node</b>(+<i>Text</i>:character_code_list,-<i>Element</i>:object_id)
<br><br>Create a DOM text node object.
<br>
<br><b>arg</b>: <i>Text</i>. a string (represented as a character code list).
<br><b>arg</b>: <i>Element</i>. an object ID structure for an HTML text node object.
<br><b>cat</b>: dom.
</li>

<li class="indexed" id="pred_dom_create_object_2">
<h5>dom_create_object/2</h5>
<br><b>dom_create_object</b>(+<i>Type</i>:atom,-<i>Object</i>:object_id)
<br><br>Same as dom_create_object/3 with Spec = [].
<br>
<br><b>arg</b>: <i>Type</i>. an atom that specifies the kind of object to create.
<br><b>arg</b>: <i>Object</i>. an object ID structure for a Web API (or other Javascript) object.
<br><b>cat</b>: dom.
</li>

<li class="indexed" id="pred_dom_create_object_3">
<h5>dom_create_object/3</h5>
<br><b>dom_create_object</b>(+<i>Type</i>:atom,-<i>Object</i>:object_id,+<i>Spec</i>:list)
<br><br>Create a Javascript object specified by the Type.
    The Type term is the constructor name and arguments (if any).
    The type argument may be of the form ModuleName : Type.
    An argument may be a goal_function type, in which case the ModuleName (inferred or explicit)
    is needed to determine what module holds the predicate(s) of the goal_functor.
    Argument types include: object, string, string_codes, integer, number, boolean, position, goal_function,
    event, and options. Also a type may specify a list or array of items of the same type as 'array_type(Type)', e.g.
    'array_type(integer)' for an array/list of integers.
<br>
<br><b>arg</b>: <i>Type</i>. an atom or structure that specifies the kind of object to create.
<br><b>arg</b>: <i>Object</i>. an object ID structure for a Web API (or other Javascript) object.
<br><b>arg</b>: <i>Spec</i>. a list specifying the types of the arguments of the Type structure (if any)..
<br><b>cat</b>: dom.
</li>

<li class="indexed" id="pred_dom_element_attribute_value_3">
<h5>dom_element_attribute_value/3</h5>
<br><b>dom_element_attribute_value</b>(+<i>Element</i>:object_id,+<i>Attribute</i>:atom,+<i>Value</i>:atom) is det
<br><b>dom_element_attribute_value</b>(+<i>Element</i>:object_id,+<i>Attribute</i>:atom,-<i>Value</i>:atom) is nondet
<br><b>dom_element_attribute_value</b>(+<i>Element</i>:object_id,-<i>Attribute</i>:atom,+<i>Value</i>:atom) is nondet
<br><b>dom_element_attribute_value</b>(-<i>Element</i>:object_id,+<i>Attribute</i>:atom,+<i>Value</i>:atom) is nondet
<br><b>dom_element_attribute_value</b>(+<i>Element</i>:object_id,-<i>Attribute</i>:atom,-<i>Value</i>:atom) is nondet
<br><b>dom_element_attribute_value</b>(-<i>Element</i>:object_id,+<i>Attribute</i>:atom,-<i>Value</i>:atom) is nondet
<br><b>dom_element_attribute_value</b>(-<i>Element</i>:object_id,-<i>Attribute</i>:atom,+<i>Value</i>:atom) is nondet
<br><b>dom_element_attribute_value</b>(-<i>Element</i>:object_id,-<i>Attribute</i>:atom,-<i>Value</i>:atom) is nondet
<br><br>There may be any combination of bindings of Element, Attribute, Value, including none bound.
     If Element is unbound and Attribute and Value are bound then dom_element_attribute_value/3 has two
     strategies for finding Element: if Attribute and Value are bound and Attribute is 'id', 'name', or 'class'
     then use specific Javascript document getElementById(Value), getElementsByName(Value), or getElementsByClass(Value) method
     where Attribute is 'id', 'name', or 'class', respectively; otherwise, get all
     elements using document.querySelectorAll('*') and check each one using element.getAttribute(Attribute)=Value.

     If Attribute is unbound then dom_element_attribute_value/3 checks each possible Element
     using Javascript element.getAttributeNames() to generate all values for Attribute for each Element. For each Attribute and Element value
     the value is checked/retrieved. As above, 'id', 'name',
     and 'class' attributes are handled specially; all other attributes are handled
     using element.getAttribute(Attribute)=Value.
<br>
<br><b>arg</b>: <i>Element</i>.  DOM Element object identifier.
<br><b>arg</b>: <i>Attribute</i>. an atom naming an attribute.
<br><b>arg</b>: <i>Value</i>. an atom specifying the value to be assigned to the attribute.
<br><b>cat</b>: dom.
</li>

<li class="indexed" id="pred_dom_object_method_2">
<h5>dom_object_method/2</h5>
<br><b>dom_object_method</b>(+<i>Object</i>:object_id,:<i>MethodStructure</i>:callable_term)
<br><br>This predicate is the same as dom_object_method/3 with a SpecTerm = [].
<br>
<br><b>cat</b>: dom.
</li>

<li class="indexed" id="pred_dom_object_method_3">
<h5>dom_object_method/3</h5>
<br><b>dom_object_method</b>(+<i>Object</i>:object_id,:<i>MethodStructure</i>:callable_term,+<i>SpecTerm</i>:list)
<br><br>Evaluate a Javascript method applied to a Javascript Web API object.
     The result of the method (if any) is unified with the last argument
     of the Method structure.
     The Method argument may be qualified with a module name or
     an argument of the Method structure may be qualified. For example:
     dom_object_method(Element, add_event_listener(click, 'foo:bar'(thing)))
     or
     dom_object_method(Element, foo : add_event_listener(click, bar(thing))).
     In the second case, the 'foo' module name is used in conjunction with
     the meta-argument type definition for 'add_event_listener' second argument
     (of '0') to determine
     that 'bar(thing)' should be qualified as 'foo:bar'(thing).
     If the foo module had imported bar/1 from the quux module, then this
     qualification would be 'quux:bar'(thing).
     The SpecTerm is used to define the method call when it is not already defined.
     The SpecTerm has the form [MethodName, ArgTypes, ReturnType] or [MethodName, ArgTypes] if no return.
     
<br>
<br><b>arg</b>: <i>Object</i>. an object ID structure for a Web API (or other Javascript) object.
<br><b>arg</b>: <i>MethodStructure</i>. a term of the form 'methodName(arg1, arg2, ..)'.
<br><b>arg</b>: <i>SpecTerm</i>. either [] or the form [MethodName, ArgTypes, ReturnType] or [MethodName, ArgTypes] if no return.
<br><b>cat</b>: dom.
</li>

<li class="indexed" id="pred_dom_object_property_4">
<h5>dom_object_property/4</h5>
<br><b>dom_object_property</b>(+<i>Type</i>:atom,+<i>Object</i>:object_id,+<i>Property</i>:atom,-<i>Value</i>:term) is nondet
<br><b>dom_object_property</b>(+<i>Type</i>:atom,-<i>Object</i>:object_id,+<i>Property</i>:atom,+<i>Value</i>:term) is nondet
<br><b>dom_object_property</b>(-<i>Type</i>:atom,+<i>Object</i>:object_id,+<i>Property</i>:atom,+<i>Value</i>:term) is det
<br><b>dom_object_property</b>(+<i>Type</i>:atom,+<i>Object</i>:object_id,+<i>Property</i>:atom,+<i>Value</i>:term) is det
<br><br>Determine each Value of Property of Object of Type.
     Property must be a ground value.
     At least two of Type, Object, and Value must be ground.
<br>
<br><b>arg</b>: <i>Type</i>. an atom specifying the object type.
<br><b>arg</b>: <i>Object</i>. an object ID structure for a Web API (or other Javascript) object.
<br><b>arg</b>: <i>Property</i>. an atom naming a defined property for the related object.
<br><b>arg</b>: <i>Value</i>. a term specifying the value of the named property of the related object.
<br><b>cat</b>: dom.
</li>

<li class="indexed" id="pred_dom_object_type_2">
<h5>dom_object_type/2</h5>
<br><b>dom_object_type</b>(+<i>Object</i>:object_id,?<i>Type</i>:atom)
<br><br>Relate a Javascript object to its ProscriptLS type.
    A Web API object that is an instance of HTMLElement has the type 'htmlelement'.
<br>
<br><b>arg</b>: <i>Object</i>. an object ID structure for a Web API (or other Javascript) object.
<br><b>arg</b>: <i>Type</i>. an atom naming the type of the associated object.
<br><b>cat</b>: dom.
</li>

<li class="indexed" id="pred_dom_release_object_1">
<h5>dom_release_object/1</h5>
<br><b>dom_release_object</b>(+<i>Object</i>:object_id)
<br><br>Release internal registration of Javascript structure for Object
<br>
<br><b>arg</b>: <i>Object</i>. an object ID structure for a Web API (or other Javascript) object.
<br><b>cat</b>: dom.
</li>

<li class="indexed" id="pred_dom_select_all_elements_2">
<h5>dom_select_all_elements/2</h5>
<br><b>dom_select_all_elements</b>(<i>Query</i>,<i>Element</i>) is nondet
<br><br>Select each HTML Element that satisfies the specified Query.
<br>
<br><b>arg</b>: <i>Query</i>. a string (represented as a character code list).
<br><b>arg</b>: <i>Element</i>. an object ID structure for an HTML element object.
<br><b>cat</b>: dom.
</li>

<li class="indexed" id="pred_dom_select_element_2">
<h5>dom_select_element/2</h5>
<br><b>dom_select_element</b>(+<i>Query</i>:character_code_list,?<i>Element</i>:object_id)
<br><br>Select an HTML Element that satisfies the specified Query.
<br>
<br><b>arg</b>: <i>Query</i>. a string (represented as a character code list).
<br><b>arg</b>: <i>Element</i>. an object ID structure for an HTML element object.
<br><b>cat</b>: dom.
</li>

<li class="indexed" id="pred_dom_type_method_5">
<h5>dom_type_method/5</h5>
<br><b>dom_type_method</b>(?<i>ObjectType</i>:atom,?<i>MethodName</i>:atom,?<i>ImplementationName</i>:atom,?<i>ArgumentTypes</i>:list,?<i>ResultType</i>:atom)
<br><br>Find the related values for a WebInterface API object type, a method name implemented for that type, the Javascript Web API function name used
     to implement that method, the types of arguments for that method, and the result type (possibly undefined).
<br>
<br><b>arg</b>: <i>ObjectType</i>. an atom naming a Web API interface.
<br><b>arg</b>: <i>MethodName</i>. an atom naming a method of a Web API interface.
<br><b>arg</b>: <i>ImplementationName</i>. an atom naming Javascript function that implements a method of a Web API interface.
<br><b>arg</b>: <i>ArgumentTypes</i>. a list of data type specifications for the inputs of an API method..
<br><b>arg</b>: <i>ResultType</i>. an atom specifying the result data type (if any) of an API method.
<br><b>cat</b>: dom.
</li>

<li class="indexed" id="pred_dom_type_parent_2">
<h5>dom_type_parent/2</h5>
<br><b>dom_type_parent</b>(?<i>ObjectType</i>:atom,?<i>ParentType</i>:atom)
<br><br>Web API interface ObjectType has parent interface ParentType.
<br>
<br><b>arg</b>: <i>ObjectType</i>. an atom naming a Web API interface.
<br><b>arg</b>: <i>ParentType</i>. an atom naming a Web API interface.
<br><b>cat</b>: dom.
</li>

<li class="indexed" id="pred_dom_type_property_4">
<h5>dom_type_property/4</h5>
<br><b>dom_type_property</b>(?<i>ObjectType</i>:atom,?<i>PropertyName</i>:atom,?<i>JsName</i>:atom,?<i>ValueType</i>:atom)
<br><br>Find the related values for a WebInterface API ObjectType, a PropertyName implemented for that type, the Javascript Web API function JsName used
     to implement that property, and the ValueType for that property.
    
<br>
<br><b>arg</b>: <i>ObjectType</i>. an atom naming a Web API interface.
<br><b>arg</b>: <i>PropertyName</i>. an atom naming a property of a Web API interface.
<br><b>arg</b>: <i>JsName</i>. an atom naming the Javascript function that implements getting the value of a property of a Web API interface.
<br><b>arg</b>: <i>ValueType</i>. an atom specifying the data type returned by a Javascript method.
<br><b>cat</b>: dom.
</li>

<li class="indexed" id="pred_dom_type_reference_4">
<h5>dom_type_reference/4</h5>
<br><b>dom_type_reference</b>(?<i>Type</i>:atom,?<i>Name</i>:atom,?<i>Standard</i>:atom,?<i>Mdn</i>:atom)
<br><br>Relates DOM Web API type and name with reference URLs in W3C standards and Mozilla MDN. This predicate is used in generating ProscriptLS documentation.
<br>
<br><b>arg</b>: <i>Type</i>. an atom that is the ProscriptLS name (all lowercase) of the Web API interface.
<br><b>arg</b>: <i>Name</i>. an atom that is the Web API interface name (proper case).
<br><b>arg</b>: <i>Standard</i>. an atom that is the URL to a W3C reference for the associated Web API name.
<br><b>arg</b>: <i>Mdn</i>. an atom that is the URL to a Mozilla MDN reference for the associated Web API name.
<br><b>cat</b>: dom.
</li>

<li class="indexed" id="pred_dom_window_1">
<h5>dom_window/1</h5>
<br><b>dom_window</b>(?<i>Window</i>:object_id) is det
<br><br>Window is the object ID for the Web API interface HTML Window object.
<br>
<br><b>arg</b>: <i>Window</i>. the object ID for the HTML window object.
<br><b>cat</b>: dom.
</li>

<li class="indexed" id="pred_insert_before_dom_node_3">
<h5>insert_before_dom_node/3</h5>
<br><b>insert_before_dom_node</b>(+<i>Parent</i>:object_id,+<i>Element</i>:object_id,+<i>Before</i>:object_id)
<br><br>Insert child Element before Before element with parent Parent element.
<br>
<br><b>arg</b>: <i>Parent</i>. an object ID structure for an HTML node object.
<br><b>arg</b>: <i>Element</i>. an object ID structure for an HTML node object.
<br><b>arg</b>: <i>Before</i>. an object ID structure for an HTML node object.
<br><b>cat</b>: dom.
</li>

<li class="indexed" id="pred_remove_dom_element_class_2">
<h5>remove_dom_element_class/2</h5>
<br><b>remove_dom_element_class</b>(<i>Element</i>,<i>Class</i>)
<br><br>Remove Class from classes defined for Element.
<br>
<br><b>cat</b>: dom.
</li>

<li class="indexed" id="pred_replace_dom_element_class_2">
<h5>replace_dom_element_class/2</h5>
<br><b>replace_dom_element_class</b>(<i>Element</i>,<i>Class</i>)
<br><br>Replace Class in classes defined for Element.
<br>
<br><b>cat</b>: dom.
</li>

<li class="indexed" id="pred_set_dom_element_attribute_value_3">
<h5>set_dom_element_attribute_value/3</h5>
<br><b>set_dom_element_attribute_value</b>(+<i>Element</i>:object_id,+<i>Attribute</i>:atom,+<i>Value</i>:atom)
<br><br>Set DOM element attribute to value.
<br>
<br><b>arg</b>: <i>Element</i>.  DOM Element object identifier.
<br><b>arg</b>: <i>Attribute</i>. an atom naming an attribute.
<br><b>arg</b>: <i>Value</i>. an atom specifying the value to be assigned to the attribute.
<br><b>cat</b>: dom.
</li>

<li class="indexed" id="pred_set_dom_object_property_3">
<h5>set_dom_object_property/3</h5>
<br><b>set_dom_object_property</b>(<i>Object</i>,<i>Property</i>,<i>Value</i>)
<br><br>Set Property of Object to Value. Property must be in a defined Web API interface for
    ProscriptLS for the interface type for Object or one of its parent types.
<br>
<br><b>arg</b>: <i>Object</i>. object_id of a Javascript object that is an instance of a Web API interface.
<br><b>arg</b>: <i>Property</i>. an atom naming a defined property for the associated object Web API interface.
<br><b>arg</b>: <i>Value</i>. a term of a type appropriate to the associated property.
<br><b>cat</b>: dom.
</li>

<li class="indexed" id="pred_toggle_dom_element_class_3">
<h5>toggle_dom_element_class/3</h5>
<br><b>toggle_dom_element_class</b>(<i>Element</i>,<i>Class</i>,<i>Mode</i>)
<br><br>Toggle Class in classes defined for Element with Mode of either 'add' or 'remove'.
<br>
<br><b>cat</b>: dom.
</li>

</ul>
</div>
<div class="indexed" id="pred_cat_flag_updates">
<h4>flag_updates</h4>
<ul>
<li class="indexed" id="pred_current_prolog_flag_2">
<h5>current_prolog_flag/2</h5>
<br><b>current_prolog_flag</b>(+<i>Flag</i>:term,?<i>Value</i>:term) is det
<br><b>current_prolog_flag</b>(-<i>Flag</i>:term,?<i>Value</i>:term) is nondet
<br><br>Prolog Flag has Value. The defined flags are: bounded,
    max_integer, min_integer, integer_rounding_function,
    char_conversion, debug, max_arity, unknown, double_quotes, and dialect.
<br>
<br><b>arg</b>: <i>Flag</i>. a defined flag atom.
<br><b>arg</b>: <i>Value</i>. a Prolog term.
<br><b>compat</b>: iso.
<br><b>cat</b>: flag_updates.
</li>

<li class="indexed" id="pred_set_prolog_flag_2">
<h5>set_prolog_flag/2</h5>
<br><b>set_prolog_flag</b>(+<i>Flag</i>:term,?<i>Value</i>:term) is det
<br><br>Set Prolog Flag to Value. Only certain flags are settable: char_conversion, debug, unknown, double_quotes, wam_log, and wam_log_size.
<br>
<br><b>arg</b>: <i>Flag</i>. a defined flag atom.
<br><b>arg</b>: <i>Value</i>. a Prolog term.
<br><b>compat</b>: iso.
<br><b>cat</b>: flag_updates.
</li>

</ul>
</div>
<div class="indexed" id="pred_cat_logic_and_control">
<h4>logic_and_control</h4>
<ul>
<li class="indexed" id="pred_fail_0">
<h5>fail/0</h5>
<br><b>fail</b> is det
<br><br>This goal always fails.
<br>
<br><b>compat</b>: iso.
<br><b>cat</b>: logic_and_control.
</li>

<li class="indexed" id="pred_halt_0">
<h5>halt/0</h5>
<br><b>halt</b> is det
<br><br>Halt the WAM engine. The engine may be restarted - typically after evaluating the backtrack Javascript function.
<br>
<br><b>compat</b>: iso.
<br><b>cat</b>: logic_and_control.
</li>

<li class="indexed" id="pred_repeat_0">
<h5>repeat/0</h5>
<br><b>repeat</b> is nondet
<br><br>Always succeeds on initial call and on all redo calls (it backtracks without bound).
<br>
<br><b>compat</b>: iso.
<br><b>cat</b>: logic_and_control.
</li>

<li class="indexed" id="pred_true_0">
<h5>true/0</h5>
<br><b>true</b> is det
<br><br>This goal always succeeds.
<br>
<br><b>compat</b>: iso.
<br><b>cat</b>: logic_and_control.
</li>

<li class="indexed" id="pred_yield_0">
<h5>yield/0</h5>
<br><b>yield</b> is det
<br><br>Yield (suspend) the WAM engine to allow any waiting HTML events to be processed.
     The yield/0 predicate completes after these waiting events have been handled.
     This can be used to make changes to the current web page and have them rendered
     immediately instead of when the current top level query completes.
<br>
<br><b>compat</b>: proscriptls.
<br><b>cat</b>: logic_and_control.
</li>

</ul>
</div>
<div class="indexed" id="pred_cat_memory_file">
<h4>memory_file</h4>
<ul>
<li class="indexed" id="pred_copy_local_storage_to_memory_file_2">
<h5>copy_local_storage_to_memory_file/2</h5>
<br><b>copy_local_storage_to_memory_file</b>(+<i>Key</i>:atom,+<i>MemoryFile</i>:memory_file_specifier) is det
<br><br>Copy from Window.localStorage at the specified key to the memory_file.
<br>
<br><b>compat</b>: proscriptls.
<br><b>cat</b>: memory_file.
</li>

<li class="indexed" id="pred_copy_memory_file_to_local_storage_2">
<h5>copy_memory_file_to_local_storage/2</h5>
<br><b>copy_memory_file_to_local_storage</b>(+<i>MemoryFile</i>:memory_file_specifier,+<i>Key</i>:atom) is det
<br><br>Copy from a memory file to Window.localStorage using the specified key.
<br>
<br><b>compat</b>: proscriptls.
<br><b>cat</b>: memory_file.
</li>

<li class="indexed" id="pred_free_memory_file_1">
<h5>free_memory_file/1</h5>
<br><b>free_memory_file</b>(+<i>MemoryFile</i>:memory_file_specifier) is det
<br><br>Free the internal storage for the memory file.
<br>
<br><b>compat</b>: proscriptls.
<br><b>cat</b>: memory_file.
</li>

<li class="indexed" id="pred_new_memory_file_1">
<h5>new_memory_file/1</h5>
<br><b>new_memory_file</b>(-<i>MemoryFile</i>:memory_file_specifier) is det
<br><br>Create a memory file. This allocates internal storage that should be freed using free_memory_file/1.
<br>
<br><b>compat</b>: proscriptls.
<br><b>cat</b>: memory_file.
</li>

<li class="indexed" id="pred_open_memory_file_3">
<h5>open_memory_file/3</h5>
<br><b>open_memory_file</b>(+<i>MemoryFile</i>:memory_file_specifier,+<i>Mode</i>:stream_mode_atom,-<i>Stream</i>:stream_specifier) is det
<br><br>Open a stream to read from , write into, or append to the given memory file.
<br>
<br><b>compat</b>: proscriptls.
<br><b>cat</b>: memory_file.
</li>

</ul>
</div>
<div class="indexed" id="pred_cat_runtime">
<h4>runtime</h4>
<ul>
<li class="indexed" id="pred_statistics_0">
<h5>statistics/0</h5>
<br><b>statistics</b> is det
<br><br>Display runtime statistics. These include WAM duration, current heap size in words,
    maximum heap size encountered, and maximum stack size encountered.
<br>
<br><b>compat</b>: iso.
<br><b>cat</b>: runtime.
</li>

<li class="indexed" id="pred_statistics_max_heap_1">
<h5>statistics_max_heap/1</h5>
<br><b>statistics_max_heap</b>(?<i>Value</i>:integer) is det
<br><br>Size in words of the maximum storage allocated in the WAM heap since the WAM was initialized
<br>
<br><b>arg</b>: <i>Value</i>. an integer.
<br><b>compat</b>: proscriptls.
<br><b>cat</b>: runtime.
</li>

<li class="indexed" id="pred_statistics_max_stack_1">
<h5>statistics_max_stack/1</h5>
<br><b>statistics_max_stack</b>(?<i>Value</i>:integer) is det
<br><br>Size in words of the maximum storage allocated in the WAM stack since the WAM was initialized
<br>
<br><b>arg</b>: <i>Value</i>. an integer.
<br><b>compat</b>: proscriptls.
<br><b>cat</b>: runtime.
</li>

<li class="indexed" id="pred_wam_duration_1">
<h5>wam_duration/1</h5>
<br><b>wam_duration</b> is det
<br><br>Milliseconds spent in the WAM since start of the WAM
<br>
<br><b>arg</b>: <i>Value</i>. an integer.
<br><b>compat</b>: proscriptls.
<br><b>cat</b>: runtime.
</li>

</ul>
</div>
<div class="indexed" id="pred_cat_stream_selection_and_control">
<h4>stream_selection_and_control</h4>
<ul>
<li class="indexed" id="pred_at_end_of_stream_1">
<h5>at_end_of_stream/1</h5>
<br><b>at_end_of_stream</b>(+<i>Stream</i>:term)
<br><br>Stream position is at its end.
<br>
<br><b>arg</b>: <i>Stream</i>. a stream term.
<br><b>compat</b>: iso.
<br><b>cat</b>: stream_selection_and_control.
</li>

<li class="indexed" id="pred_close_1">
<h5>close/1</h5>
<br><b>close</b>(+<i>Stream</i>:term)
<br><br>Close Stream.
<br>
<br><b>arg</b>: <i>Stream</i>. a stream term.
<br><b>compat</b>: iso.
<br><b>cat</b>: stream_selection_and_control.
</li>

<li class="indexed" id="pred_current_input_1">
<h5>current_input/1</h5>
<br><b>set_input</b>(+<i>Stream</i>:term)
<br><br>Current input stream is Stream.
<br>
<br><b>arg</b>: <i>Stream</i>. a stream term.
<br><b>compat</b>: iso.
<br><b>cat</b>: stream_selection_and_control.
</li>

<li class="indexed" id="pred_current_output_1">
<h5>current_output/1</h5>
<br><b>set_output</b>(+<i>Stream</i>:term)
<br><br>Current output stream is Stream.
<br>
<br><b>arg</b>: <i>Stream</i>. a stream term.
<br><b>compat</b>: iso.
<br><b>cat</b>: stream_selection_and_control.
</li>

<li class="indexed" id="pred_flush_output_1">
<h5>flush_output/1</h5>
<br><b>flush_output</b>(+<i>Stream</i>:term)
<br><br>Flush output Stream.
<br>
<br><b>arg</b>: <i>Stream</i>. a stream term.
<br><b>compat</b>: iso.
<br><b>cat</b>: stream_selection_and_control.
</li>

<li class="indexed" id="pred_open_3">
<h5>open/3</h5>
<br><b>open</b>(+<i>SourceSink</i>:term,+<i>Mode</i>:atom,-<i>Stream</i>:term) is det
<br><br>Open a text file source or sink with default options, creating a Stream term by which to access that source or sink.
<br>
<br><b>arg</b>: <i>SourceSink</i>. a term.
<br><b>arg</b>: <i>Mode</i>. a stream mode atom: 'read', 'write', 'append'.
<br><b>compat</b>: iso.
<br><b>cat</b>: stream_selection_and_control.
</li>

<li class="indexed" id="pred_open_4">
<h5>open/4</h5>
<br><b>open</b>(+<i>SourceSink</i>:term,+<i>Mode</i>:atom,-<i>Stream</i>:term,+<i>Options</i>:list) is det
<br><br>Open a source or sink, creating a Stream term by which to access that source or sink.
<br>
<br><b>arg</b>: <i>SourceSink</i>. a term.
<br><b>arg</b>: <i>Mode</i>. a stream mode atom: 'read', 'write', 'append'.
<br><b>arg</b>: <i>Options</i>. a list of stream options.
<br><b>compat</b>: iso.
<br><b>cat</b>: stream_selection_and_control.
</li>

<li class="indexed" id="pred_set_input_1">
<h5>set_input/1</h5>
<br><b>set_input</b>(+<i>Stream</i>:term)
<br><br>Sets current input stream to Stream.
<br>
<br><b>arg</b>: <i>Stream</i>. a stream term.
<br><b>compat</b>: iso.
<br><b>cat</b>: stream_selection_and_control.
</li>

<li class="indexed" id="pred_set_output_1">
<h5>set_output/1</h5>
<br><b>set_output</b>(+<i>Stream</i>:term)
<br><br>Sets current output stream to Stream.
<br>
<br><b>arg</b>: <i>Stream</i>. a stream term.
<br><b>compat</b>: iso.
<br><b>cat</b>: stream_selection_and_control.
</li>

<li class="indexed" id="pred_set_stream_position_2">
<h5>set_stream_position/2</h5>
<br><b>set_stream_position</b>(+<i>Stream</i>:term,+<i>Position</i>:integer)
<br><br>Set Stream position to Position.
<br>
<br><b>arg</b>: <i>Stream</i>. a stream term.
<br><b>arg</b>: <i>Position</i>. an integer.
<br><b>compat</b>: iso.
<br><b>cat</b>: stream_selection_and_control.
</li>

<li class="indexed" id="pred_stream_property_2">
<h5>stream_property/2</h5>
<br><b>stream_property</b>(?<i>Stream</i>:term,?<i>Property</i>:term)
<br><br>Enumerates all the pairs of open streams together with their properties.
<br>
<br><b>arg</b>: <i>Stream</i>. a stream term.
<br><b>arg</b>: <i>Property</i>. a property term.
<br><b>compat</b>: iso.
<br><b>cat</b>: stream_selection_and_control.
</li>

</ul>
</div>
<div class="indexed" id="pred_cat_term_comparison">
<h4>term_comparison</h4>
<ul>
<li class="indexed" id="pred_==_2">
<h5>(==)/2</h5>
<br><b>==</b>(?<i>Term1</i>:term,?<i>Term2</i>:term) is det
<br><br>Term1 matches Term2. Two terms match if they are equal without binding any variables.
<br>
<br><b>arg</b>: <i>Term1</i>. any Prolog term.
<br><b>arg</b>: <i>Term2</i>. any Prolog term.
<br><b>compat</b>: iso.
<br><b>cat</b>: term_comparison.
</li>

<li class="indexed" id="pred_@<_2">
<h5>(@<)/2</h5>
<br><b>@<</b>(?<i>Term1</i>:term,?<i>Term2</i>:term) is det
<br><br>Term1 is less than Term2. This predicate can be used as an infix operator.
<br>
<br><b>arg</b>: <i>Term1</i>. a Prolog term.
<br><b>arg</b>: <i>Term2</i>. a Prolog term.
<br><b>compat</b>: iso.
<br><b>cat</b>: term_comparison.
</li>

<li class="indexed" id="pred_@=<_2">
<h5>(@=<)/2</h5>
<br><b>@=<</b>(?<i>Term1</i>:term,?<i>Term2</i>:term) is det
<br><br>Term1 is less than or equal to Term2. This predicate can be used as an infix operator.
<br>
<br><b>arg</b>: <i>Term1</i>. a Prolog term.
<br><b>arg</b>: <i>Term2</i>. a Prolog term.
<br><b>compat</b>: iso.
<br><b>cat</b>: term_comparison.
</li>

<li class="indexed" id="pred_@>_2">
<h5>(@>)/2</h5>
<br><b>@></b>(?<i>Term1</i>:term,?<i>Term2</i>:term) is det
<br><br>Term1 is greater than Term2. This predicate can be used as an infix operator.
<br>
<br><b>arg</b>: <i>Term1</i>. a Prolog term.
<br><b>arg</b>: <i>Term2</i>. a Prolog term.
<br><b>compat</b>: iso.
<br><b>cat</b>: term_comparison.
</li>

<li class="indexed" id="pred_@>=_2">
<h5>(@>=)/2</h5>
<br><b>@>=</b>(?<i>Term1</i>:term,?<i>Term2</i>:term) is det
<br><br>Term1 is greater than or equal to Term2. This predicate can be used as an infix operator.
<br>
<br><b>arg</b>: <i>Term1</i>. a Prolog term.
<br><b>arg</b>: <i>Term2</i>. a Prolog term.
<br><b>compat</b>: iso.
<br><b>cat</b>: term_comparison.
</li>

<li class="indexed" id="pred_compare_3">
<h5>compare/3</h5>
<br><b>compare</b>(?<i>Comparison</i>:atom,?<i>Term1</i>:term,?<i>Term2</i>:term) is det
<br><br>Comparison is the term-ordering between Term1 and Term2: < if Term1 @< Term2, = if Term1 == Term2, and > if
    Term1 @> Term2.
<br>
<br><b>arg</b>: <i>Comparison</i>. <, =, or >.
<br><b>arg</b>: <i>Term1</i>. a Prolog term.
<br><b>arg</b>: <i>Term2</i>. a Prolog term.
<br><b>compat</b>: swi.
<br><b>cat</b>: term_comparison.
</li>

<li class="indexed" id="pred_subsumes_term_2">
<h5>subsumes_term/2</h5>
<br><b>subsumes_term</b>(?<i>Term1</i>:term,?<i>Term2</i>:term) is det
<br><br>Term1 subsumes Term2.
<br>
<br><b>arg</b>: <i>Term1</i>. any Prolog term.
<br><b>arg</b>: <i>Term2</i>. any Prolog term.
<br><b>compat</b>: iso.
<br><b>cat</b>: term_comparison.
</li>

</ul>
</div>
<div class="indexed" id="pred_cat_term_creation_and_decomposition">
<h4>term_creation_and_decomposition</h4>
<ul>
<li class="indexed" id="pred_=.._2">
<h5>(=..)/2</h5>
<br><b>=..</b>(?<i>Term</i>:term,?<i>List</i>:list) is det
<br><br>Term univ List. List is a list [Functor|Args] where functor(Term, Functor, Arity)
     and Args are the arguments of Term (if any):
     forall(between(1, Arity, N), (arg(N, Term, Arg), nth1(N, Args, Arg))).
     If Args is null then Term is atomic (either an atom or a number) and is equal to Functor.
<br>
<br><b>arg</b>: <i>Term</i>. any Prolog term.
<br><b>arg</b>: <i>List</i>. a list.
<br><b>compat</b>: iso.
<br><b>cat</b>: term_creation_and_decomposition.
</li>

<li class="indexed" id="pred_arg_3">
<h5>arg/3</h5>
<br><b>arg</b>(+<i>Position</i>:integer,+<i>Term</i>:term,?<i>Arg</i>:term) is det
<br><br>Argument at Position of Term is Arg. 
<br>
<br><b>arg</b>: <i>Position</i>. an integer.
<br><b>arg</b>: <i>Term</i>. a term.
<br><b>arg</b>: <i>Arg</i>. a term.
<br><b>compat</b>: iso.
<br><b>cat</b>: term_creation_and_decomposition.
</li>

<li class="indexed" id="pred_atom_to_term_3">
<h5>atom_to_term/3</h5>
<br><b>atom_to_term</b>(+<i>Atom</i>:atom,?<i>Term</i>:term,?<i>Bindings</i>:list) is det
<br><br>Term is the result of reading the name of Atom with the ProscriptLS parser. Bindings is a list of terms of the form 'name = variable'
    where 'name' is the name of each variable found in Atom and 'variable' is the ProscriptLS variable to which that named variable
    is converted in Term.
<br>
<br><b>arg</b>: <i>Atom</i>. an atom.
<br><b>arg</b>: <i>Term</i>. a term.
<br><b>arg</b>: <i>Bindings</i>. a list of (Name = Variable) terms.
<br><b>compat</b>: proscriptls.
<br><b>cat</b>: term_creation_and_decomposition.
</li>

<li class="indexed" id="pred_copy_term_2">
<h5>copy_term/2</h5>
<br><b>copy_term</b>(?<i>Term1</i>:term,?<i>Term2</i>:term) is det
<br><br>Term2 is the same as Term1 but with distinct variables such that Term1 and Term2 subsume each other and the
    variables of Term2 have not appeared in the proof tree before evaluating this predicate.
<br>
<br><b>arg</b>: <i>Term1</i>. a Prolog term.
<br><b>arg</b>: <i>Term2</i>. a Prolog term.
<br><b>compat</b>: iso.
<br><b>cat</b>: term_creation_and_decomposition.
</li>

<li class="indexed" id="pred_functor_3">
<h5>functor/3</h5>
<br><b>functor</b>(+<i>Term</i>:integer,?<i>Name</i>:term,?<i>Arity</i>:term) is det
<br><b>functor</b>(-<i>Term</i>:integer,+<i>Name</i>:term,+<i>Arity</i>:term) is det
<br><br>Term has functor Name and Arity arguments. 
<br>
<br><b>arg</b>: <i>Term</i>. any Prolog term.
<br><b>arg</b>: <i>Name</i>. an atom.
<br><b>arg</b>: <i>Arity</i>. an integer.
<br><b>compat</b>: iso.
<br><b>cat</b>: term_creation_and_decomposition.
</li>

<li class="indexed" id="pred_term_variables_2">
<h5>term_variables/2</h5>
<br><b>term_variables</b>(?<i>Term</i>:term,?<i>Variables</i>:list) is det
<br><br>Variables are the variables in Term.
<br>
<br><b>arg</b>: <i>Term</i>. a term.
<br><b>arg</b>: <i>Variables</i>. a list of one term (variable) for each variable in Term.
<br><b>compat</b>: proscriptls.
<br><b>cat</b>: term_creation_and_decomposition.
</li>

</ul>
</div>
<div class="indexed" id="pred_cat_term_io">
<h4>term_io</h4>
<ul>
<li class="indexed" id="pred_char_conversion_2">
<h5>char_conversion/2</h5>
<br><b>char_conversion</b>(+<i>InChar</i>:atom,+<i>OutChar</i>:atom) is det
<br><br>Add conversion of InChar to OutChar to the character conversion table. (This should be
    a directive.)
<br>
<br><b>arg</b>: <i>InChar</i>. a single-character atom.
<br><b>arg</b>: <i>OutChar</i>. a single-character atom.
<br><b>compat</b>: iso.
<br><b>cat</b>: term_io.
</li>

<li class="indexed" id="pred_current_char_conversion_2">
<h5>current_char_conversion/2</h5>
<br><b>current_char_conversion</b>(-<i>InChar</i>:atom,-<i>OutChar</i>:atom) is nondet
<br><b>current_char_conversion</b>(+<i>InChar</i>:atom,-<i>OutChar</i>:atom) is det
<br><b>current_char_conversion</b>(-<i>InChar</i>:atom,+<i>OutChar</i>:atom) is det
<br><b>current_char_conversion</b>(+<i>InChar</i>:atom,+<i>OutChar</i>:atom) is det
<br><br>Character conversion table specifies that InChar is converted to OutChar when reading streams.
<br>
<br><b>arg</b>: <i>InChar</i>. a single-character atom.
<br><b>arg</b>: <i>OutChar</i>. a single-character atom.
<br><b>compat</b>: iso.
<br><b>cat</b>: term_io.
</li>

<li class="indexed" id="pred_current_op_3">
<h5>current_op/3</h5>
<br><b>current_op</b>(?<i>Priority</i>:integer,?<i>Specifier</i>:atom,?<i>Operator</i>:atom)
<br><br>Operator is currently defined with Priority and Specifier for reading and writing terms.
<br>
<br><b>arg</b>: <i>Priority</i>. an integer.
<br><b>arg</b>: <i>Specifier</i>. an atom: fx, fy, xfx, xfy, yfx, yf, xf.
<br><b>arg</b>: <i>Operator</i>. an atom.
<br><b>compat</b>: iso.
<br><b>cat</b>: term_io.
</li>

<li class="indexed" id="pred_op_3">
<h5>op/3</h5>
<br><b>op</b>(?<i>Priority</i>:integer,?<i>Specifier</i>:atom,?<i>Operator</i>:atom)
<br><br>Update the operator table with Operator as defined with Priority and Specifier for reading and writing terms.
<br>
<br><b>arg</b>: <i>Priority</i>. an integer.
<br><b>arg</b>: <i>Specifier</i>. an atom: fx, fy, xfx, xfy, yfx, yf, xf.
<br><b>arg</b>: <i>Operator</i>. an atom.
<br><b>compat</b>: iso.
<br><b>cat</b>: term_io.
</li>

<li class="indexed" id="pred_read_term_2">
<h5>read_term/2</h5>
<br><b>read_term</b>(?<i>Term</i>:term,+<i>Options</i>:list)
<br><br>Reads from the current input stream a single Term and instantiates
    accordingly the read Options list. (as described by ISO standard)
<br>
<br><b>arg</b>: <i>Term</i>. a term.
<br><b>arg</b>: <i>Options</i>. a read options list.
<br><b>compat</b>: iso.
<br><b>cat</b>: term_io.
</li>

<li class="indexed" id="pred_read_term_3">
<h5>read_term/3</h5>
<br><b>read_term</b>(+<i>Stream</i>:stream_term,?<i>Term</i>:term,+<i>Options</i>:list)
<br><br>Reads from Stream a single Term and instantiates
    accordingly the read Options list.
<br>
<br><b>arg</b>: <i>Stream</i>. a stream term.
<br><b>arg</b>: <i>Term</i>. a term.
<br><b>arg</b>: <i>Options</i>. a read options list.
<br><b>compat</b>: iso.
<br><b>cat</b>: term_io.
</li>

<li class="indexed" id="pred_write_term_3">
<h5>write_term/3</h5>
<br><b>write_term</b>(+<i>Stream</i>:term,+<i>Term</i>:term,+<i>Options</i>:list(write_option_term))
<br><br>Write Term to Stream in a form determined by Options.
<br>
<br><b>arg</b>: <i>Stream</i>. a stream term.
<br><b>arg</b>: <i>Term</i>. a term.
<br><b>arg</b>: <i>Options</i>. a list of write_term option terms - quoted(true/false), numbervars(true/false), ignore_ops(true/false), max_depth(N).
<br><b>compat</b>: iso.
<br><b>cat</b>: term_io.
</li>

<li class="indexed" id="pred_writeln_1">
<h5>writeln/1</h5>
<br><b>writeln</b>(+<i>Term</i>:term)
<br><br>Write Term followed by a newline to the current output stream.
<br>
<br><b>arg</b>: <i>Term</i>. a term.
<br><b>compat</b>: proscriptls.
<br><b>cat</b>: term_io.
</li>

</ul>
</div>
<div class="indexed" id="pred_cat_term_unification">
<h4>term_unification</h4>
<ul>
<li class="indexed" id="pred_=_2">
<h5>(=)/2</h5>
<br><b>=</b>(?<i>Term1</i>:term,?<i>Term2</i>:term) is det
<br><br>Term1 unifies with Term2.
<br>
<br><b>arg</b>: <i>Term1</i>. any Prolog term.
<br><b>arg</b>: <i>Term2</i>. any Prolog term.
<br><b>compat</b>: iso.
<br><b>cat</b>: term_unification.
</li>

<li class="indexed" id="pred_\=_2">
<h5>(\=)/2</h5>
<br><b>\=</b>(?<i>Term1</i>:term,?<i>Term2</i>:term) is det
<br><br>Term1 does not unify with Term2.
<br>
<br><b>arg</b>: <i>Term1</i>. any Prolog term.
<br><b>arg</b>: <i>Term2</i>. any Prolog term.
<br><b>compat</b>: iso.
<br><b>cat</b>: term_unification.
</li>

</ul>
</div>
<div class="indexed" id="pred_cat_type_testing">
<h4>type_testing</h4>
<ul>
<li class="indexed" id="pred_acyclic_term_1">
<h5>acyclic_term/1</h5>
<br><b>acyclic_term</b>(?<i>Term</i>:term) is det
<br><br>Term is a acyclic.
<br>
<br><b>arg</b>: <i>Term</i>. any Prolog term.
<br><b>compat</b>: iso.
<br><b>cat</b>: type_testing.
</li>

<li class="indexed" id="pred_atom_1">
<h5>atom/1</h5>
<br><b>atom</b>(?<i>Term</i>:term) is det
<br><br>Term is an atom.
<br>
<br><b>arg</b>: <i>Term</i>. any Prolog term.
<br><b>compat</b>: iso.
<br><b>cat</b>: type_testing.
</li>

<li class="indexed" id="pred_compound_1">
<h5>compound/1</h5>
<br><b>compound</b>(?<i>Term</i>:term) is det
<br><br>Term is compound - either a structure or a list.
<br>
<br><b>arg</b>: <i>Term</i>. any Prolog term.
<br><b>compat</b>: iso.
<br><b>cat</b>: type_testing.
</li>

<li class="indexed" id="pred_float_1">
<h5>float/1</h5>
<br><b>float</b>(?<i>Term</i>:term) is det
<br><br>Term is a float (i.e. a number represented with a decimal point).
<br>
<br><b>arg</b>: <i>Term</i>. any Prolog term.
<br><b>compat</b>: iso.
<br><b>cat</b>: type_testing.
</li>

<li class="indexed" id="pred_ground_1">
<h5>ground/1</h5>
<br><b>ground</b>(?<i>Term</i>:term) is det
<br><br>Term is ground - is not a variable nor is it a compound containing a variable.
<br>
<br><b>arg</b>: <i>Term</i>. any Prolog term.
<br><b>compat</b>: iso.
<br><b>cat</b>: type_testing.
</li>

<li class="indexed" id="pred_integer_1">
<h5>integer/1</h5>
<br><b>integer</b>(?<i>Term</i>:term) is det
<br><br>Term is an integer.
<br>
<br><b>arg</b>: <i>Term</i>. any Prolog term.
<br><b>compat</b>: iso.
<br><b>cat</b>: type_testing.
</li>

<li class="indexed" id="pred_var_1">
<h5>var/1</h5>
<br><b>var</b>(?<i>Term</i>:term) is det
<br><br>Term is a variable.
<br>
<br><b>arg</b>: <i>Term</i>. any Prolog term.
<br><b>compat</b>: iso.
<br><b>cat</b>: type_testing.
</li>

</ul>
</div>
